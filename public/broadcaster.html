<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Transmissor - WebRTC Live Streaming</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700;800&display=swap" rel="stylesheet">
    <style>
        :root{
            --bg: linear-gradient(135deg, #5B86E5 0%, #36D1DC 100%);
            --card-bg: rgba(255,255,255,0.1);
            --card-border: rgba(255,255,255,0.25);
            --text: #0f172a;
            --text-inverse: #ffffff;
            --shadow: 0 20px 40px rgba(0,0,0,0.15);
            --radius-xl: 18px;
            --radius-lg: 14px;
            --radius-md: 12px;
            --primary: #2563eb;
            --success: #16a34a;
            --danger: #dc2626;
            --warning: #f59e0b;
            --muted: #64748b;
            --glass: saturate(180%) blur(12px);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--bg);
            min-height: 100vh;
            padding: 1rem;
            color: var(--text);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            background: var(--card-bg);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border: 1px solid var(--card-border);
            padding: 1.5rem;
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
            text-align: center;
            color: var(--text-inverse);
        }

        h1 {
            color: #fff;
            margin-bottom: 0.35rem;
            font-size: 2.2rem;
            letter-spacing: .2px;
        }

        .controls {
            position: sticky;
            top: 0.5rem;
            z-index: 20;
            background: var(--card-bg);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border: 1px solid var(--card-border);
            padding: 1rem 1.25rem;
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
            display: flex;
            flex-wrap: wrap;
            gap: 0.75rem;
            align-items: center;
            justify-content: center;
        }

        .btn {
            padding: 0.8rem 1.4rem;
            border: 1px solid rgba(255,255,255,0.25);
            border-radius: var(--radius-md);
            font-size: 0.95rem;
            font-weight: 700;
            letter-spacing: .3px;
            cursor: pointer;
            transition: transform .18s ease, box-shadow .18s ease, opacity .18s ease;
            text-decoration: none;
            display: inline-block;
            min-width: 160px;
            color: var(--text-inverse);
            box-shadow: 0 10px 20px rgba(0,0,0,.15);
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 16px 26px rgba(0, 0, 0, 0.25), 0 0 0 2px rgba(255,255,255,0.15) inset;
            filter: drop-shadow(0 6px 14px rgba(0,0,0,.25));
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn-primary { background: linear-gradient(180deg, #ef4444, #dc2626); }
        .btn-secondary { background: linear-gradient(180deg, #34d399, #10b981); }
        .btn-danger { background: linear-gradient(180deg, #f97316, #ea580c); }
        .btn-muted { background: linear-gradient(180deg, #64748b, #475569); }
        .btn-home { background: linear-gradient(180deg, #60a5fa, #2563eb); }

        .video-container {
            background: var(--card-bg);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border: 1px solid var(--card-border);
            padding: 1.25rem;
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
        }

        .video-wrapper {
            position: relative;
            background: #0b0f19;
            border-radius: 16px;
            overflow: hidden;
            aspect-ratio: 16/9;
            max-width: 960px;
            margin: 0 auto;
            border: 1px solid rgba(255,255,255,0.08);
            box-shadow: 0 24px 48px rgba(0,0,0,.35);
        }

        #localVideo {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-overlay {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: linear-gradient(transparent, rgba(0, 0, 0, 0.8));
            color: #e5e7eb;
            padding: 1rem;
            font-size: 0.92rem;
        }

        .status-panel {
            background: var(--card-bg);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            border: 1px solid var(--card-border);
            padding: 1.25rem;
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow);
            margin-bottom: 1rem;
            color: var(--text-inverse);
        }

        .status-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
        }

        .status-item {
            padding: 1rem;
            background: rgba(255,255,255,0.08);
            border: 1px solid rgba(255,255,255,0.12);
            border-radius: var(--radius-lg);
            text-align: center;
            color: var(--text-inverse);
        }

        .status-label {
            font-size: 0.85rem;
            color: #cbd5e1;
            margin-bottom: 0.5rem;
            letter-spacing: .3px;
        }

        .status-value {
            display: inline-block;
            font-size: 0.95rem;
            font-weight: 700;
            padding: .35rem .7rem;
            border-radius: 999px;
            border: 1px solid rgba(255,255,255,0.25);
            background: rgba(255,255,255,0.12);
            color: #e5e7eb;
        }

        .status-connected { background: linear-gradient(180deg, #34d39955, #10b98155); color: #ecfdf5; }
        .status-disconnected { background: linear-gradient(180deg, #fca5a555, #ef444455); color: #fee2e2; }
        .status-transmitting { background: linear-gradient(180deg, #93c5fd55, #3b82f655); color: #dbeafe; }

        .logs {
            background: var(--card-bg);
            border: 1px solid var(--card-border);
            backdrop-filter: var(--glass);
            -webkit-backdrop-filter: var(--glass);
            padding: 1.25rem;
            border-radius: var(--radius-xl);
            box-shadow: var(--shadow);
            color: var(--text-inverse);
        }

        .logs h3 {
            margin-bottom: 1rem;
            color: #ffffff;
            letter-spacing: .3px;
        }

        #logContainer {
            background: rgba(2, 6, 23, 0.85);
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 12px;
            border: 1px solid rgba(255,255,255,0.1);
            height: 220px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.9rem;
            line-height: 1.4;
            box-shadow: inset 0 0 0 1px rgba(255,255,255,0.05);
        }

        .log-entry {
            margin-bottom: 0.25rem;
        }

        .log-info {
            color: #63b3ed;
        }

        .log-success {
            color: #68d391;
        }

        .log-warning {
            color: #f6ad55;
        }

        .log-error {
            color: #fc8181;
        }

        @media (max-width: 768px) {
            .controls {
                flex-direction: column;
            }

            .status-grid {
                grid-template-columns: 1fr;
            }

            h1 {
                font-size: 1.5rem;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- Cabe√ßalho -->
        <div class="header">
            <h1>üìπ Transmissor WebRTC</h1>
            <p>Compartilhe seu v√≠deo e √°udio ao vivo com espectadores</p>
        </div>

        <!-- Controles -->
        <div class="controls">
            <button id="startBtn" class="btn btn-primary">Iniciar C√¢mera</button>
            <button id="flipCameraBtn" class="btn btn-muted" disabled>üîÑ Virar C√¢mera</button>
            <button id="broadcastBtn" class="btn btn-secondary" disabled>Come√ßar Transmiss√£o</button>
            <button id="stopBtn" class="btn btn-danger" disabled>Parar Transmiss√£o</button>
            <a href="/" class="btn btn-home">‚Üê Voltar ao In√≠cio</a>
        </div>

        <!-- Container do V√≠deo -->
        <div class="video-container">
            <div class="video-wrapper">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-overlay">
                    <div id="videoStatus">C√¢mera desligada</div>
                </div>
            </div>
        </div>

        <!-- Painel de Status -->
        <div class="status-panel">
            <div class="status-grid">
                <div class="status-item">
                    <div class="status-label">Status da Conex√£o</div>
                    <div id="connectionStatus" class="status-value status-disconnected">Desconectado</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Espectadores</div>
                    <div id="viewerCount" class="status-value">0</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Status da Transmiss√£o</div>
                    <div id="broadcastStatus" class="status-value status-disconnected">Parada</div>
                </div>
                <div class="status-item">
                    <div class="status-label">Qualidade do V√≠deo</div>
                    <div id="videoQuality" class="status-value">-</div>
                </div>
            </div>
        </div>

        <!-- Logs -->
        <div class="logs">
            <h3>üìã Log de Atividades</h3>
            <div id="logContainer"></div>
        </div>
    </div>

    <script>
        // Vari√°veis globais
        let localStream = null;
        let peerConnections = new Map(); // M√∫ltiplas conex√µes para m√∫ltiplos espectadores
        let ws = null;
        let isTransmitting = false;
        let currentFacingMode = 'user'; // 'user' = frontal, 'environment' = traseira
        let availableCameras = [];

        // Elementos DOM
        const startBtn = document.getElementById('startBtn');
        const flipCameraBtn = document.getElementById('flipCameraBtn');
        const broadcastBtn = document.getElementById('broadcastBtn');
        const stopBtn = document.getElementById('stopBtn');
        const localVideo = document.getElementById('localVideo');
        const videoStatus = document.getElementById('videoStatus');
        const connectionStatus = document.getElementById('connectionStatus');
        const viewerCount = document.getElementById('viewerCount');
        const broadcastStatus = document.getElementById('broadcastStatus');
        const videoQuality = document.getElementById('videoQuality');
        const logContainer = document.getElementById('logContainer');

        // Configura√ß√£o WebRTC (servidores STUN/TURN p√∫blicos para testes)
        const rtcConfiguration = {
            iceServers: [
                { urls: 'stun:stun.l.google.com:19302' },
                { urls: 'stun:stun1.l.google.com:19302' }
            ]
        };

        // Fun√ß√£o para adicionar logs com timestamp e cores
        function addLog(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString('pt-BR');
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.innerHTML = `[${timestamp}] ${message}`;
            logContainer.appendChild(logEntry);
            logContainer.scrollTop = logContainer.scrollHeight;
            
            // Manter apenas os √∫ltimos 100 logs
            while (logContainer.children.length > 100) {
                logContainer.removeChild(logContainer.firstChild);
            }
        }

        // Inicializar conex√£o WebSocket
        function initializeWebSocket() {
            const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${wsProtocol}//${window.location.host}`);

            ws.onopen = function() {
                addLog('Conex√£o WebSocket estabelecida', 'success');
                connectionStatus.textContent = 'Conectado';
                connectionStatus.className = 'status-value status-connected';
                
                // Registrar como transmissor
                ws.send(JSON.stringify({
                    type: 'register-broadcaster'
                }));
            };

            ws.onmessage = function(event) {
                const data = JSON.parse(event.data);
                handleWebSocketMessage(data);
            };

            ws.onclose = function() {
                addLog('Conex√£o WebSocket perdida', 'warning');
                connectionStatus.textContent = 'Desconectado';
                connectionStatus.className = 'status-value status-disconnected';
                
                // Tentar reconectar ap√≥s 3 segundos
                setTimeout(initializeWebSocket, 3000);
            };

            ws.onerror = function(error) {
                addLog('Erro WebSocket: ' + error.message, 'error');
            };
        }

        // Processar mensagens WebSocket
        function handleWebSocketMessage(data) {
            switch (data.type) {
                case 'registered':
                    addLog(`Registrado como ${data.role}`, 'success');
                    updateViewerCount(data.viewerCount || 0);
                    break;

                case 'viewer-connected':
                    addLog('Novo espectador conectado', 'info');
                    updateViewerCount(data.viewerCount);
                    
                    // Se estamos transmitindo, criar nova conex√£o peer para o espectador
                    if (isTransmitting) {
                        createPeerConnectionForNewViewer(data.viewerId);
                    }
                    break;

                case 'viewer-disconnected':
                    addLog('Espectador desconectado', 'info');
                    updateViewerCount(data.viewerCount);
                    
                    // Fechar conex√£o peer espec√≠fica
                    if (data.viewerId && peerConnections.has(data.viewerId)) {
                        const peerConnection = peerConnections.get(data.viewerId);
                        peerConnection.close();
                        peerConnections.delete(data.viewerId);
                        addLog(`Conex√£o peer fechada para espectador ${data.viewerId}`, 'info');
                    }
                    break;

                case 'answer':
                    // Receber resposta SDP do espectador
                    addLog(`Resposta SDP recebida do espectador ${data.viewerId}`, 'info');
                    handleAnswer(data.answer, data.viewerId);
                    break;

                case 'ice-candidate':
                    // Receber ICE candidate do espectador
                    addLog(`ICE candidate recebido do espectador ${data.viewerId}`, 'info');
                    handleIceCandidate(data.candidate, data.viewerId);
                    break;

                case 'error':
                    addLog(`Erro do servidor: ${data.message}`, 'error');
                    break;

                default:
                    addLog(`Mensagem desconhecida: ${data.type}`, 'warning');
            }
        }

        // Atualizar contador de espectadores
        function updateViewerCount(count) {
            viewerCount.textContent = count;
        }

        // Detectar c√¢meras dispon√≠veis
        async function detectAvailableCameras() {
            try {
                const devices = await navigator.mediaDevices.enumerateDevices();
                availableCameras = devices.filter(device => device.kind === 'videoinput');
                addLog(`Detectadas ${availableCameras.length} c√¢meras`, 'info');
                
                // Habilitar bot√£o de alternar c√¢mera se houver mais de uma
                if (availableCameras.length > 1) {
                    flipCameraBtn.disabled = false;
                    addLog('Bot√£o de alternar c√¢mera habilitado', 'info');
                }
            } catch (error) {
                addLog(`Erro ao detectar c√¢meras: ${error.message}`, 'warning');
            }
        }

        // Iniciar c√¢mera e microfone
        async function startCamera(facingMode = currentFacingMode) {
            try {
                addLog('Solicitando acesso √† c√¢mera e microfone...', 'info');
                
                // Parar stream anterior se existir
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Configura√ß√µes de v√≠deo com facingMode
                const videoConstraints = {
                    width: { ideal: 1280 },
                    height: { ideal: 720 },
                    frameRate: { ideal: 30 }
                };

                // Adicionar facingMode se suportado
                if (facingMode) {
                    videoConstraints.facingMode = facingMode;
                }

                // Solicitar permiss√µes com configura√ß√µes otimizadas para transmiss√£o
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: videoConstraints,
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Mostrar v√≠deo local
                localVideo.srcObject = localStream;
                
                addLog(`C√¢mera iniciada (${facingMode === 'user' ? 'frontal' : 'traseira'})`, 'success');
                videoStatus.textContent = `C√¢mera ${facingMode === 'user' ? 'frontal' : 'traseira'} - Pronto para transmitir`;
                
                // Atualizar controles
                startBtn.disabled = true;
                broadcastBtn.disabled = false;
                flipCameraBtn.disabled = false;
                
                // Mostrar qualidade do v√≠deo
                const videoTrack = localStream.getVideoTracks()[0];
                const settings = videoTrack.getSettings();
                videoQuality.textContent = `${settings.width}x${settings.height} @ ${settings.frameRate}fps`;

                // Detectar c√¢meras dispon√≠veis
                await detectAvailableCameras();

                // Se estiver transmitindo, atualizar as conex√µes peer
                if (isTransmitting) {
                    await updatePeerConnectionsWithNewStream();
                }

            } catch (error) {
                addLog(`Erro ao acessar c√¢mera: ${error.message}`, 'error');
                alert('Erro ao acessar c√¢mera e microfone. Verifique as permiss√µes.');
            }
        }

        // Alternar entre c√¢mera frontal e traseira
        async function flipCamera() {
            try {
                addLog('Alternando c√¢mera...', 'info');
                flipCameraBtn.disabled = true;
                
                // Alternar facingMode
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
                
                // Reiniciar c√¢mera com novo facingMode
                await startCamera(currentFacingMode);
                
                addLog(`C√¢mera alternada para ${currentFacingMode === 'user' ? 'frontal' : 'traseira'}`, 'success');
                
            } catch (error) {
                addLog(`Erro ao alternar c√¢mera: ${error.message}`, 'error');
                // Reverter facingMode em caso de erro
                currentFacingMode = currentFacingMode === 'user' ? 'environment' : 'user';
            } finally {
                flipCameraBtn.disabled = false;
            }
        }

        // Atualizar conex√µes peer com novo stream
        async function updatePeerConnectionsWithNewStream() {
            if (!localStream) return;
            
            addLog('Atualizando stream para espectadores...', 'info');
            
            for (const [viewerId, peerConnection] of peerConnections) {
                try {
                    // Remover tracks antigos
                    const senders = peerConnection.getSenders();
                    for (const sender of senders) {
                        if (sender.track) {
                            peerConnection.removeTrack(sender);
                        }
                    }
                    
                    // Adicionar novos tracks
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });
                    
                    addLog(`Stream atualizado para espectador ${viewerId}`, 'info');
                } catch (error) {
                    addLog(`Erro ao atualizar stream para espectador ${viewerId}: ${error.message}`, 'error');
                }
            }
        }

        // Criar conex√£o peer para novo espectador
        function createPeerConnectionForNewViewer(viewerId) {
            const peerConnection = new RTCPeerConnection(rtcConfiguration);
            peerConnections.set(viewerId, peerConnection);

            addLog(`Criando conex√£o peer para espectador ${viewerId}`, 'info');

            // Adicionar stream local √† conex√£o
            if (localStream) {
                localStream.getTracks().forEach(track => {
                    peerConnection.addTrack(track, localStream);
                });
            }

            // Configurar eventos da conex√£o peer
            setupPeerConnectionEvents(peerConnection, viewerId);

            // Criar e enviar oferta SDP
            createAndSendOffer(peerConnection, viewerId);
        }

        // Configurar eventos da conex√£o peer
        function setupPeerConnectionEvents(peerConnection, viewerId) {
            // ICE candidates
            peerConnection.onicecandidate = function(event) {
                if (event.candidate) {
                    addLog(`Enviando ICE candidate para espectador ${viewerId}`, 'info');
                    ws.send(JSON.stringify({
                        type: 'ice-candidate',
                        candidate: event.candidate,
                        target: 'viewer',
                        viewerId: viewerId
                    }));
                }
            };

            // Estado da conex√£o
            peerConnection.onconnectionstatechange = function() {
                addLog(`Estado da conex√£o ${viewerId}: ${peerConnection.connectionState}`, 'info');
                
                if (peerConnection.connectionState === 'connected') {
                    addLog(`Espectador ${viewerId} conectado com sucesso`, 'success');
                } else if (peerConnection.connectionState === 'failed' || 
                          peerConnection.connectionState === 'disconnected') {
                    addLog(`Espectador ${viewerId} desconectado`, 'warning');
                    peerConnections.delete(viewerId);
                }
            };

            // Estado do ICE
            peerConnection.oniceconnectionstatechange = function() {
                addLog(`Estado ICE ${viewerId}: ${peerConnection.iceConnectionState}`, 'info');
            };
        }

        // Criar e enviar oferta SDP
        async function createAndSendOffer(peerConnection, viewerId) {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);
                
                addLog('Oferta SDP criada e configurada', 'success');
                
                // Enviar oferta via WebSocket
                ws.send(JSON.stringify({
                    type: 'offer',
                    offer: offer,
                    viewerId: viewerId
                }));
                
                addLog(`Oferta SDP enviada para espectador ${viewerId}`, 'info');

            } catch (error) {
                addLog(`Erro ao criar oferta: ${error.message}`, 'error');
            }
        }

        // Processar resposta SDP do espectador
        async function handleAnswer(answer, viewerId) {
            try {
                // Encontrar a conex√£o peer correspondente ao viewerId
                const peerConnection = peerConnections.get(viewerId);
                
                if (peerConnection) {
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(answer));
                    addLog(`Resposta SDP configurada para espectador ${viewerId}`, 'success');

                    // Processar ICE candidates pendentes (recebidos antes da descri√ß√£o remota)
                    if (peerConnection.pendingCandidates && peerConnection.pendingCandidates.length > 0) {
                        addLog(`Processando ${peerConnection.pendingCandidates.length} ICE candidates pendentes para ${viewerId}`, 'info');
                        for (const c of peerConnection.pendingCandidates) {
                            try {
                                await peerConnection.addIceCandidate(new RTCIceCandidate(c));
                            } catch (e) {
                                addLog(`Falha ao aplicar ICE pendente: ${e.message}`, 'warning');
                            }
                        }
                        peerConnection.pendingCandidates = [];
                    }
                } else {
                    addLog(`Conex√£o peer n√£o encontrada para espectador ${viewerId}`, 'error');
                }
            } catch (error) {
                addLog(`Erro ao processar resposta: ${error.message}`, 'error');
            }
        }

        // Processar ICE candidate do espectador
        async function handleIceCandidate(candidate, viewerId) {
            try {
                // Encontrar a conex√£o peer correspondente ao viewerId
                const peerConnection = peerConnections.get(viewerId);
                
                if (peerConnection) {
                    // Verificar se a descri√ß√£o remota foi configurada antes de adicionar ICE candidate
                    if (peerConnection.remoteDescription) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        addLog(`ICE candidate processado para espectador ${viewerId}`, 'info');
                    } else {
                        addLog(`Aguardando descri√ß√£o remota para espectador ${viewerId}`, 'warning');
                        // Armazenar candidate para processar depois
                        if (!peerConnection.pendingCandidates) {
                            peerConnection.pendingCandidates = [];
                        }
                        peerConnection.pendingCandidates.push(candidate);
                    }
                } else {
                    addLog(`Conex√£o peer n√£o encontrada para espectador ${viewerId}`, 'error');
                }
                
            } catch (error) {
                addLog(`Erro ao processar ICE candidate: ${error.message}`, 'error');
            }
        }

        // Iniciar transmiss√£o
        function startBroadcast() {
            if (!localStream) {
                alert('Inicie a c√¢mera primeiro!');
                return;
            }

            isTransmitting = true;
            addLog('Transmiss√£o iniciada', 'success');
            
            // Atualizar UI
            broadcastBtn.disabled = true;
            stopBtn.disabled = false;
            broadcastStatus.textContent = 'Transmitindo';
            broadcastStatus.className = 'status-value status-transmitting';
            videoStatus.textContent = 'AO VIVO - Transmitindo para espectadores';

            // Criar conex√£o inicial para espectadores j√° conectados
            // Nota: conex√µes ser√£o criadas quando espectadores se conectarem

            // Notificar servidor que a transmiss√£o come√ßou
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'start-broadcast'
                }));
                addLog('Servidor notificado: transmiss√£o iniciada', 'info');
            }
        }

        // Parar transmiss√£o
        function stopBroadcast() {
            isTransmitting = false;
            addLog('Transmiss√£o parada', 'warning');
            
            // Fechar todas as conex√µes peer
            peerConnections.forEach((peerConnection) => {
                peerConnection.close();
            });
            peerConnections.clear();
            
            // Notificar servidor
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({
                    type: 'stop-broadcast'
                }));
            }
            
            // Atualizar UI
            broadcastBtn.disabled = false;
            stopBtn.disabled = true;
            broadcastStatus.textContent = 'Parada';
            broadcastStatus.className = 'status-value status-disconnected';
            videoStatus.textContent = 'C√¢mera ligada - Pronto para transmitir';
        }

        // Event listeners
        startBtn.addEventListener('click', startCamera);
        flipCameraBtn.addEventListener('click', flipCamera);
        broadcastBtn.addEventListener('click', startBroadcast);
        stopBtn.addEventListener('click', stopBroadcast);

        // Inicializar quando a p√°gina carregar
        document.addEventListener('DOMContentLoaded', function() {
            addLog('P√°gina do transmissor carregada', 'info');
            initializeWebSocket();
        });

        // Limpar recursos quando a p√°gina for fechada
        window.addEventListener('beforeunload', function() {
            if (isTransmitting) {
                stopBroadcast();
            }
            
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>